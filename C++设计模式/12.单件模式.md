- # "对象性能"模式
  - 面向对象很好地解决了“抽象”的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。
  - 典型模式
      - Singleton
      - Flyweight
      
- # 动机
  - 在软件系统中，经常有这样一类特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。
  - 如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？
  - 这应该是类设计者的责任，而不是使用者的责任。
  
- # 模式定义
  保证一个类仅有一个实例，并提供一个实例的全局访问点。
  
- # 结构
![结构](https://github.com/havenow/my-C-plus-plus/blob/master/C%2B%2B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/%E7%BB%93%E6%9E%84%EF%BC%88Structure%EF%BC%89-singleton.png)  

- # 要点总结
  - Singleton模式中的实例构造器可以设置为protected以允许子类派生。
  - Singleton模式一般不要支持拷贝构造函数和Clone接口，因为这有可能导致多个对象实例，与Singleton模式的初衷违背。
  - 如何实现多线程环境下安全的Singleton？注意对双检查锁的正确实现。
  
  
