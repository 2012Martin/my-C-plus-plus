- # 使用makefile
以下操作在mac上完成  
```c++
//hello.c
#include <stdio.h>

int main(int argc, char** argv)
{
        printf("hello\n");
        return 0;
}

//执行命令
gcc -o hello hello.c  
./hello 
//在命令行打印出了hello
```

```makefile
//写一个makefile文件
hello:hello.c
        gcc -o hello hello.c
clean:
        rm hello

//在命令行打印出了hello
//执行命令
make
./hello
//在命令行打印出了hello
```

```makefile
//有中间文件的makefile文件
hello:hello.o
        gcc -o hello hello.o
hello.o:hello.c
        gcc -o hello.o -c hello.c #-c表示只编译不链接
clean:
        rm hello hello.o
```

- # 程序文件的分类  
- bin文件  
纯粹的代码，一般用在裸机上，比如单片机上，编译代码，烧到单片机上，可以直接运行   

- elf文件  
(一般运行在linux操作系统上，elf文件时有头部信息的)  
可执行文件(比如 hello)   
可重定位文件(比如 hello.o)  
库文件(目标文件的归档，静态库 动态库) 

`readelf -h hello`  
可以看到有一个entry point address  0x8048310(mac上没有readelf命令？)

`readelf -h hello.o`
可以看到entry point address  0x0  
只有这些可重定位文件组装成可执行文件后这个地址才不是0  

```
file hello
file hello.o
```
可以查看文件的类型
```
hello: elf 32-bit lsb executable,…
hello.o: elf 32-bit lsb relocatable,…
```

- # makefile文件的主要内容  
规则  
变量  
条件执行  
文本、文件名处理函数  
文件包含  
注释   

makefile的目的是构建依赖关系树，依赖关系树的生命周期  
- 解析阶段载入内存  
- 运行阶段根据其进行编译、根据时间戳生成文件  
- 有新文件添加、减少会动态改变依赖关系树  

###############################################################################
- # makefile文件的主要内容  
规则  
变量  
条件执行  
文本、文件名处理函数  
文件包含  
注释   

makefile的目的是构建依赖关系树，依赖关系树的生命周期  
- 解析阶段载入内存  
- 运行阶段根据其进行编译、根据时间戳生成文件  
- 有新文件添加、减少会动态改变依赖关系树  


- # 规则
规则：
      目标 目标依赖 命令
      target：prerequisites
         <tab>command

注意：
1. 命令行必须以tab键开始，一般是shell命令  
2. 一个规则中可以无目标依赖，仅仅实现某些操作(clean: rm …)  
3. 一个规则中可以没有命令，仅仅描述依赖关系(.PHONY:clean)  
4. 一个规则中必须有一个目标  

make命令默认在当前目录下寻找名字为makefile或者Makefile的工程文件，当名字不为这两者之一时，可以使用如下方法指定：
　　　　make  -f  文件名

makefile文件中存在系统默认的自动化变量：
1. $^ 代表所有的依赖文件
2. $@ 代表目标文件
3. $< 代表第一个依赖文件

----------------------------------------------------------------------------
- # 目标
- 默认目标
一个makefile里可以有多个目标  
一般会选择第一个作为默认目标  
- 多目标  
一个规则可以有多个目标  
多个目标具有相同的生成命令和依赖文件  
- 多规则目标  
多个规则可以是同一个目标  
make在解析时，会将多个规则的依赖文件合并  
- 伪目标  
并不是一个真正的文件名，可以看做是一个标签  
无依赖，相比一般文件不会去重新生成、生成  
伪目标，可以无条件执行   

----------------------------------------------------------------------------
- # 目标依赖
- 文件时间戳  
根据时间戳来判断目标依赖文件是否更新  
所有文件编译过，则对所有文件编译，生成可执行程序  
在上次make之后修改过的c文件，会被重新编译  
在上次make之后修改的头文件，依赖此头文件的会被重新编译  

- 自动产生依赖  
`gcc -M 文件`  
`gcc -MM 文件`  不包含系统的依赖  
此命令生成改文件要依赖的文件  

- 隐式规则  

- 模式匹配  
```
%.o:%.c
	gcc -o $@ -c $^
```

----------------------------------------------------------------------------
- # 生成命令  
- 命令的组成  
shell命令组成、tab键开头  

- 命令的执行  
每条命令，make会开一个进程  
每条命令执行完，make会监测每个命令的返回码  
若命令返回成功，make继续执行下个命令  
若命令执行错误，make会终止当前规则，退出  

- 并发执行命令  
`make -j3`开三个进程同时编译  

- 命令同一进程执行  
```
all:
	cd /; \
	pwd
```
使用;和\将两个命令组合成一个，这样两个命令就在一进程执行  
